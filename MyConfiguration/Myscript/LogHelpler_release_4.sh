#!/bin/bash
#
# Description:
#   For the purpose of tracing the call tree of java program, this script is used to add Log.d() at the entrance and exit of all 
#   methods of all classes of a java file, what's more, it also add Log.d() at every branch, such as "if ... else if ... else" and "case ... :".
#   It can deal with a single file or a whole directroy at one time. If you want to add some additional Log.d() statements for 
#   some purpose in specific method, don't use the same format as the script used, namely Log.d(TAG, "*****##### Enter/Leave/Create ... #####*****),
#   because this script support option "clean" which will delete 
#   all lines in this format. If you meet some errors when use the file, you can use option "debug" to debug
# 
#   Sometimes, errors will encounter when compile the file treated by this script, usually "unreachedable statement", go to the line 
#   and delete it.
#
#
# Parameters:
#   file: the file that you want to add Log.d().
#   file clean: clean all the Log.d() statements added by this script.
#   directroy: all files with suffix .java in the directroy will be treated.
#   directroy clean: clean all added statement in all .java file in the directroy.
#
# Usage: 
#   deal with a file:
#       to add Log.d() to this file: LogHelpler.sh /home/gary/amlogic/VodPlayerActivity.java
#       to clean the Log.d() from this file: LogHelpler.sh /home/gary/amlogic/VodPlayerActivity.java clean
#       to debug: LogHelpler.sh /home/gary/amlogic/VodPlayerActivity.java debug
#   deal with a directroy:
#       to add Log.d(): LogHelpler.sh /home/gary/amlogic/LiveTV/
#       to clean the Log.d(): LogHelpler.sh /home/gary/amlogic/LiveTV clean
#       to debug: LogHelpler.sh /home/gary/amlogic/LiveTV debug
#       
#       you can run this script at any directroy, and the original file can be relative path or absolute path, however, you must put this 
#       script to the directory that contained by PATH to run it.
#
# Requirements:
#   ctags-exuberant must have been installed in your computer. If not, please install it throught apt-get:
#           sudo apt-get install exuberant-ctags (if it doesn't work please run "sudo apt-get install ctags" instead.)
#
# History:
#   2014-04-28  gary    Forth release
#
# Bugs:
#   If you find any bugs when you use this script, please contact:
#       hejinyi@hisense.com or 403752830@qq.com
#
# Copyright:
#       Gary(Jinyi) he, Jamdeo, Hisense
#

export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:$HOME/bin"

declare DEBUG="false"
declare -i STARTTIME
declare -i ENDTIME
STARTTIME=$(date +%s)

if [ -z $RECURSION ]; then
    declare -i RECURSION
    RECURSION=0
    export RECURSION
fi

# Set the destination dirtroy and the original dirtroy, 
# the destination dirtroy is used to store the files that generated by this script, 
# the original dirtroy is where the file that to be handled come from.

declare DESDIR
declare ORGDIR
if [ -z "$(echo $1 | grep '/')" ]; then
    ORGDIR="."
else
    ORGDIR=${1%/*}
fi
DESDIR="${HOME}/.LogHelpler_multitaskmode"
if [ $RECURSION -eq 0 ]; then
    if [ ! -d $DESDIR ]; then
        # create directroy to stroe backup of original source file
        mkdir -p ${DESDIR}/src
        # create directroy to store tags file of corresponding source file
        mkdir -p ${DESDIR}/tag
        # create directroy to store tags of methods of all class that extract from tags file
        mkdir -p ${DESDIR}/method
        # create directroy to store log file which will recording all message generated while handling
        mkdir -p ${DESDIR}/log
    fi
fi

declare FILENAME
declare SRCFILE
declare TAGFILE
declare METHODFILE
# FILENAME=${1##*/}
FILENAME=$(echo $1 | tr '/' '_')
FILENAME=${FILENAME#*_}
SRCFILE=$(echo "${DESDIR}/src/${FILENAME}")
TAGFILE=$(echo "${DESDIR}/tag/${FILENAME%.*}_tags")
METHODFILE=$(echo "${DESDIR}/method/${FILENAME%.*}_method")
LOGPREFIX="####"
LOGSUFFIX="####"
declare TMPUNREACHEDABLEFILE="/tmp/${FILENAME%.*}_LogHelplerunreachedfile"
declare HANDLINGFILE="/tmp/.LOGHELPLERHANDINGFILE"
declare LOCKFILE="/tmp/.lockfile"
declare LOCKFILEFORPID="/tmp/.lockfileforpid"
declare ORIGINALFILENAME=$1


# Since the last running of this script has generated some files, 
# such as backup of original source file, method file, tags file,
# and they are out of date now, delete them.
if [ -f "${SRCFILE}" ]; then
    rm -f ${SRCFILE}
fi
if [ -f "${TAGFILE}" ]; then
    rm -f ${TAGFILE}
fi
if [ -f "${METHODFILE}" ]; then
    rm -f ${METHODFILE}
fi

###############################################################
# Function Name: unreachedMethod
# Author: Gary
# Time: 2013-10-26
###############################################################
function unreachedMethod() {
# echo "Enter unreachedMethod"
    local currentfile
    local -i startline
    local -i endline
    local -i desline
    local -i line
    local -i wl
    local -i count
    local answer="n"
    wl=$(wc -l $TMPUNREACHEDABLEFILE | awk '{print $1}')
    if [ $wl -gt 0 ]; then
        tput setf 2
        echo "There are $wl statements maybe unreachedable, if you don't check them, there may be some errors when you make the project."
        read -p "Do you want to check them?(y/n):" answer
        tput setf 7
        if [ "$answer" == "y" -o "$answer" == "Y" ]; then
            currentfile=$(sed -n '1p' $TMPUNREACHEDABLEFILE | awk '{print $1}')
            count=1
            while [ $count -le $wl ]
            do
                if [ "$currentfile" != "$(sed -n "${count}p" $TMPUNREACHEDABLEFILE | awk '{print $1}')" ]; then
                    sed -i '/added by LogHelpler from gary -replace unreachedstatement-/d' $currentfile
                    currentfile=$(sed -n "${count}p" $TMPUNREACHEDABLEFILE | awk '{print $1}')
                fi
                startline=$(sed -n "${count}p" $TMPUNREACHEDABLEFILE | awk '{print $2}')
                endline=$(sed -n "${count}p" $TMPUNREACHEDABLEFILE | awk '{print $3}')
                desline=$(sed -n "${count}p" $TMPUNREACHEDABLEFILE | awk '{print $4}')
                line=$(($desline - 1))
                tput setf 7
                cat -n $currentfile | sed -n "${startline},${line}p"
                tput setf 4
                cat -n $currentfile | sed -n "${desline}p"
                tput setf 7
                line=$(($desline + 1))
                cat -n $currentfile | sed -n "${line},${endline}p"
                tput setf 3
                echo -e "From file: $currentfile\n"
                tput setf 2
                read -p "($count/$wl)The statement printed with red color may unreachedable. Press 'd' to delete it or 'n' to cancel (d/n):" answer
                while [ "$answer" != "d" -a "$answer" != "D" -a "$answer" != "n" -a "$answer" != "N" ]
                do
                    read -p "($count/$wl)Only 'd' or 'n' are accepted. Press 'd' to delete it or 'n' to cancel (d/n):" answer
                done
                if [ "$answer" == "d" -o "$answer" == "D" ]; then
                    sed -i "${desline}d" $currentfile
                    sed -i "${desline}i // added by LogHelpler from gary -an unreachedable location , you deleted manually-" $currentfile
                fi
                tput setf 7
                printf "\n\n"
                count=$(($count + 1))
            done
        else
            tput setf 4
            echo "You have canceled check for the unreachedable statement."
            tput setf 7
        fi
    else
        return
    fi
    unset currentfile
    unset startline
    unset endline
    unset desline
    unset line
    unset wl
    unset count
    unset answer
}
###############################################################
# END OF FUNCTION
###############################################################

###############################################################
# Function Name: clean
# Parameters: $1 which to handle
# Author: Gary
# Time: 2013-12-22
###############################################################
function clean() {
    sed -i '/^MYPREFIX/s/MYPREFIX/ /g' $1
    sed -i 's/_hejinyi/\//g' $1
    sed -i 's/hejinyi_/\//g' $1
    sed -i '/\/\/hejinyicomment/s/\/\/hejinyicomment//g' $1
    sed -i 's/hejinyiescapequota/\\"/g' $1
    sed -i '/\/\/new line by LogHelpler for comment/N;s/\n//g' $1
    sed -i '/\/\/new line by LogHelpler for comment/s/\/\/new line by LogHelpler for comment//g' $1
}
###############################################################
# End of function
###############################################################

###############################################################
# Function Name: updateProBar
# Parameters: $1 Percentage of the task that have finished
# Usage: updateProBar 68 (68 indicates 68%)
# Author: Gary
# Time: 2013-10-26
###############################################################
declare -i TERMCOLSOLD=$(tput cols)
function updateProBar() {
    local -i TERMCOLS=$(tput cols)
    local -i PROBARCOLS=$TERMCOLS
    local -i PROBARSCALE=1
    while [ $TERMCOLS -lt $((100 / $PROBARSCALE)) ]
    do
        PROBARSCALE=$PROBARSCALE+1
        PROBARCOLS=$((100 / $PROBARSCALE))
    done
    if [ $PROBARCOLS -gt 100 ]; then
            PROBARCOLS=100
    fi
	local -i FINISHCOLS=$(($1 / $PROBARSCALE))
	local -i VAR=1
	tput civis			# hiden the cursor
	printf "\n"			# Go to the next line
	tput cuu1	# Up one line, then the cursor at the 0 column
    if [ $TERMCOLSOLD -ne $TERMCOLS ]; then
        VAR=1
        while [ $VAR -le $TERMCOLS ]
        do
            printf " "
		    VAR=$VAR+1
        done
        if [ -z "$ISDIRECTROY" ]; then
            printf "\n"
            VAR=1
            while [ $VAR -le $TERMCOLS ]
            do
                printf " "
                VAR=$VAR+1
            done
            TERMCOLSOLD=$TERMCOLS
            tput cuu 2	# Up one line, then the cursor at the 0 column
            printf "\n"
        else
            tput cuu 1	# Up one line, then the cursor at the 0 column
            printf "\n"
        fi
    fi
	tput setf 2			# Set the color of foreground to green
    if [ ! -z "$ISDIRECTROY" ]; then
        printf 'Finished:%3d%% (%d/%d)\n' $1 $(($CURRENTFILE - $(wc -l $HANDLINGFILE | awk '{print $1}'))) $FILESUM
    else
        printf 'Finished:%3d%%\n' $1	# length = 13
    fi
    # if [ -z "$ISDIRECTROY" ]; then
        printf "["
        VAR=1
        while [ $VAR -le $PROBARCOLS ]
        do
            if [ $VAR -le $FINISHCOLS ]; then
                printf ">"
            else
                tput setf 7
                printf "=" 
            fi
            VAR=$VAR+1
        done
        printf "]\n"
    # fi
	if [ $1 -eq 100 ]; then
		tput cnorm
		tput setf 7
		tput bel
	else
        # if [ -z "$ISDIRECTROY" ]; then
            tput cuu 2
        # else
            # tput cuu 1
        # fi
	fi
}
###############################################################
# END OF FUNCTION
###############################################################

# Check the validity of the parameters that we input while run this script
if [ $# -lt 1 ]; then
    echo "No file has been specified, do nothing."
    tput setf 7
    exit 1
elif [ $# -gt 2 ]; then
    echo "Only one file can be handled at one time."
    tput setf 7
    exit 1
elif [ -f $1 ]; then
    if [ -z "$(echo $1 | grep '.*\.java$')" ]; then
        echo "$1 is not a java file."
        tput setf 7
        exit 1
    # elif [ -z "$(grep 'import android\..*;' $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g"| sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep 'import android\..*;')" ]; then
        # tput setf 7
        # exit 0
    elif [ $# -eq 2 -a "$2" == "clean" ]; then
        sed -r -i "/Log\.d\((\".*\"|TAG), \"$LOGPREFIX (Enter|Leave|Create).* $LOGSUFFIX\"\);|added by LogHelpler from gary/d" $1
        sed -i '/\/\/new line by LogHelpler for return/N;s/\n//g' $1
        sed -i '/\/\/new line by LogHelpler for return/s/\/\/new line by LogHelpler for return[[:space:]]*//g' $1
        sed -i '/\/\/turn on debug by LogHelpler/s/true/false/g;s/\/\/turn on debug by LogHelpler//g' $1
        clean $1
        tput setf 7
        exit 0
    elif [ $# -eq 2 -a "$2" == "debug" ]; then
        DEBUG="true"
        tput setf 7
    fi
    if [ -z "$ISDIRECTROY" ]; then
        rm -f $TMPUNREACHEDABLEFILE
        touch $TMPUNREACHEDABLEFILE
    else
        if [ $RECURSION -eq 0 ]; then
            while [ -f "$LOCKFILE" ]
            do
               cd .
            done
            touch $LOCKFILE
            echo "$(date +%T)    pid=$$    $ORIGINALFILENAME (lines = $(wc -l $ORIGINALFILENAME | awk '{print $1}'))" >> $HANDLINGFILE
            rm -f $LOCKFILE
        fi
    fi
elif [ -d $1 ]; then
    declare ISDIRECTROY="true"
    export ISDIRECTROY
    declare -i FILESUM=0
    declare -i CURRENTFILE=0
    declare -i task=4
    declare -i exits=0
    export FILESUM
    export CURRENTFILE
    declare mainpid=$$

    if [ "$(grep '^processor' /proc/cpuinfo | wc -l)" -ne 0 ]; then
        task=$(grep '^processor' /proc/cpuinfo | wc -l)
        tput setf 4
        echo "---------- Your computer has $task virtual processors, task is set to $task ----------"
        tput setf 7
    fi
    declare -i dStarttime=$(date +%s)
    rm -rf $DESDIR
    rm -f $HANDLINGFILE
    touch $HANDLINGFILE
    rm -f $TMPUNREACHEDABLEFILE
    touch $TMPUNREACHEDABLEFILE
    TASKFINISHEDOLD=0
    TASKFINISHEDNEW=0
    FILESUM=$(find $1 -type f -name "*.java" | wc -l | awk '{print $1}')
    for var in $(find $1 -type f -name "*.java")
    do
        CURRENTFILE=$(($CURRENTFILE + 1))
        $0 $var $2 &
        exits=$(ps aux | grep "$0" | grep '\.java' | wc -l)
        while [ $exits -gt $task ]
        do
            TASKFINISHEDNEW=$((($CURRENTFILE - $(wc -l $HANDLINGFILE | awk '{print $1}')) * 100 / $FILESUM))
            if [ $TASKFINISHEDOLD -lt $TASKFINISHEDNEW ]; then
                TASKFINISHEDOLD=$TASKFINISHEDNEW
                updateProBar $TASKFINISHEDNEW
            fi
            exits=$(ps aux | grep "$0" | grep '\.java' | wc -l)
        done
    done
    exits=$(ps aux | grep "$0" | grep '\.java' | wc -l)
    while [ $exits -gt 0 ]
    do
        TASKFINISHEDNEW=$((($CURRENTFILE - $(wc -l $HANDLINGFILE | awk '{print $1}')) * 100 / $FILESUM))
        if [ $TASKFINISHEDOLD -lt $TASKFINISHEDNEW ]; then
            TASKFINISHEDOLD=$TASKFINISHEDNEW
            updateProBar $TASKFINISHEDNEW
        fi
        exits=$(ps aux | grep "$0" | grep '\.java' | wc -l)
    done
    if [ "$2" == "clean" ]; then
        if [ $TASKFINISHEDOLD -ne 100 ]; then
            updateProBar 100
        fi
        exit 0
    fi
    unreachedMethod
    declare var
    for var in $(find $1 -type f -name "*.java")
    do
        rm -f /tmp/${FILENAME%.*}_hejinyiLogHelplertmp
        touch /tmp/${FILENAME%.*}_hejinyiLogHelplertmp
        awk '{gsub(/garymethodline|garycreateline/,NR)}{print $0}' $var >> /tmp/${FILENAME%.*}_hejinyiLogHelplertmp
        mv /tmp/${FILENAME%.*}_hejinyiLogHelplertmp $var
    done
    if [ $TASKFINISHEDOLD -ne 100 ]; then
        updateProBar 100
    fi
    declare -i dEndtime=$(date +%s)
    tput setf 4
    echo "TotalTime for whole directroy: $((($dEndtime - $dStarttime) / 3600))h $((($dEndtime - $dStarttime) % 3600 / 60))m $((($dEndtime - $dStarttime) % 60))s"
    tput setf 7
    exit 0
fi

if [ -z "$TAG" ]; then
    if [ $# -eq 2 ]; then
        if [ ! -z "$(echo $2 | egrep 'tag=|Tag=|TAG=')" ]; then
            declare TAG=${2##*=}
            if [ "$TAG" == "hejinyi" -o "$TAG" == "jinyihe" ]; then
                echo -n "cat't set TAG to \"$TAG\", so I set it to \"jinyi-he\" instead"
                TAG="jinyi-he"
            fi
            TAG=$(echo "\"$TAG\"")
        fi
    fi
    if [ -z "$TAG" ]; then
        # if [ -z "$(egrep 'Log\..[[:space:]]*\([[:space:]]*TAG' $1)" ]; then
            declare TAG=${1##*/}
            TAG=${TAG%.*}
            TAG=$(echo "\"$TAG\"")
        # else
            # declare TAG="TAG"
        # fi
    fi
    export TAG
fi

declare CLASSNAME
declare METHODNAME
declare METHODNAME1
declare NETHODNAME2
declare ONELINE
declare GREPPAT
declare PREFIX
declare CONTENTVAR
declare PRIVATECLASS
declare CLASSNAMECOLLECTION
declare ISABSTRACTMETHOD="false"
declare ISSINGLELINEMETHOD="false"
declare ISCONSTRUCTOR="false"
declare ISINTERFACE="false"
declare ISCLASS="false"
declare UNREACHEDABLE="unknow"
declare -i SINGLELINE=0
declare -i NEWSINGLELINE=0
declare -i STARTLINE=0
declare -i STARTLINEBACKUP=0
declare -i ENDLINE=0
declare -i ENDLINEBACKUP=0
declare -i STARTLINEFORCHECKREACHEDABLE=0
declare -i ENDLINEFORCHECKREACHEDABLE=0
declare -i DEADLINEFORCHECK=1
declare UNKNOWTYPE="false"
declare DETECTELSE="false"
declare UNDETECTED="false"
declare -i GLOBALLINE=0
declare -i count=1
declare -i WL=0
declare -i TASKFINISHEDOLD=0
declare -i TASKFINISHEDNEW=0
# between 1 ~ 10
declare -i PROBARSTEP

# create a buckup of the lastest version of the original file
sed -r -i "/Log\.d\((\".*\"|TAG), \"$LOGPREFIX (Enter|Leave|Create).* $LOGSUFFIX\"\);|added by LogHelpler from gary/d" $1
if [ $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
    count=$(tput cols)
    declare -i var=1
    printf "\n\n"
    while [ $var -le $count ]
    do
        printf "*"
        var=$(($var + 1))
    done 
    printf "\n"
    declare towrite=$(echo " Current File: $1 ")
    declare -i towritecount=$(echo $towrite | wc -m)
    if [ ! -z "$ISDIRECTROY" ]; then
        count=$((($count - $towritecount - 8) / 2))
    else
        count=$((($count - $towritecount) / 2))
    fi
    if [ $count -gt 0 ]; then
        var=1
        while [ $var -le $count ]
        do
            printf "*"
            var=$(($var + 1))
        done 
        if [ ! -z "$ISDIRECTROY" ]; then
	        printf ' %d/%d' $CURRENTFILE $FILESUM
        fi
        printf "$towrite"
        count=$(($count -1))
        var=1
        while [ $var -le $count ]
        do
            printf "*"
            var=$(($var + 1))
        done 
        printf "\n"
        count=$(tput cols)
        var=1
        while [ $var -le $count ]
        do
            printf "*"
            var=$(($var + 1))
        done 
        printf "\n"
    else
        if [ ! -z "$ISDIRECTROY" ]; then
	        printf ' %d/%d' $CURRENTFILE $FILESUM
        fi
        printf "$towrite\n"
        count=$(tput cols)
        var=1
        while [ $var -le $count ]
        do
            printf "*"
            var=$(($var + 1))
        done 
        printf "\n"
    fi
    unset var
    unset towrite
    unset towritecount
    tput setf 7
fi

# remove the tag for comment block (/* */) that may exist in this file. 
sed -r -i "/Log\.d\((\".*\"|TAG), \"$LOGPREFIX (Enter|Leave|Create).* $LOGSUFFIX\"\);|added by LogHelpler from gary/d" $1
sed -i '/\/\/new line by LogHelpler for return/N;s/\n//g' $1
sed -i '/\/\/new line by LogHelpler for return/s/\/\/new line by LogHelpler for return[[:space:]]*//g' $1
sed -i '/\/\/turn on debug by LogHelpler/s/true/false/g;s/\/\/turn on debug by LogHelpler//g' $1
clean $1
# tag the comment block (/* */), 
sed -i '/[^[:space:]][^[:space:]]*.*[^\\]\\"/s/\\"/hejinyiescapequota/g' $1
sed -i '/\/\/.*\/\*/s/\/\*/replaceleftcomment/g' $1 ## added after second release
sed -i '/".*\/\*.*"/s/\/\*/replaceleftcomment/g' $1 ## added after second release
sed -i '/".*\*\/.*"/s/\*\//replacerightcomment/g' $1 ## added after second release
# added here 2013-12-29
while [ ! -z "$(egrep '^([^"]*"[^"]*"[^"]*)+replace(left|right)comment' $1)" ]
do
    sed -i -r 's/^([^"]*"[^"]*"[^"]*)+replace(left|right)comment/&back/g' $1
    sed -i 's/replaceleftcommentback/\/\*/g' $1
    sed -i 's/replacerightcommentback/\*\//g' $1
done
# end here 2013-12-29

sed -i '/\/\*.*\*\//s/\/\*/_hejinyi\*/g' $1
sed -i '/_hejinyi\*.*\*\//s/\*\//\*hejinyi_/g' $1

sed -r -i '/[^\/]\/\*|^\/\*/,/\*\/|\*hejinyi_/s/^/\/\/hejinyicomment/g' $1
sed -i '/\/\/hejinyicomment.*\*\//s/\*\//\*\/\/\/new line by LogHelpler for comment\n/g' $1
sed -i '/\/\/hejinyicomment.*\/\*/s/hejinyicomment/hejinyicommenthead/g' $1
sed -i '/\/\/hejinyicommenthead.*\/\*/s/\/\*/\/\/hejinyicomment\/\*/g' $1
sed -i 's/\/\/hejinyicommenthead//g' $1
sed -i 's/replaceleftcomment/\/\*/g' $1 ## added after second release
sed -i 's/replacerightcomment/\*\//g' $1 ## added after second release


# Generete the tags file and the method file which is used to store the prototype of all methods of all classes of the original file.
ctags-exuberant -f ${TAGFILE} $1
egrep '[[:space:]]+m[[:space:]]+' ${TAGFILE} > ${METHODFILE}

declare -i LINESOFMETHODFILE
declare -i LINESOFSOURCEFILE
LINESOFMETHODFILE=$(wc -l ${METHODFILE} | awk '{print $1}')
LINESOFSOURCEFILE=$(wc -l $1 | awk '{print $1}')


###############################################################
# Function Name: findBrace
# Parameters: $1 leftbrace, rightbrace, leftparentheses, rightparentheses 
#             $2 original file
#             $3 start line where to begin to find brace
# Usage: findBrace $FINDTYPE $FILENAME $LINENUMBER ["startline"]
# Author: Gary
# Time: 2013-12-14
###############################################################
function findBrace() {
    local -i line
    local -i count
    local contentvar
    local file
    local plus
    local sub
    local direction
    if [ "$1" == "leftbrace" ]; then
        plus="}"
        sub="{"
        direction="up"
    elif [ "$1" == "rightbrace" ]; then
        plus="{"
        sub="}"
        direction="down"
    elif [ "$1" == "leftparentheses" ]; then
        plus=")"
        sub="("
        direction="up"
    elif [ "$1" == "rightparentheses" ]; then
        plus="("
        sub=")"
        direction="down"
    fi

    file=$2
    line=$3

    count=0
    contentvar=$(sed -n "${line}p" ${file})
    count=$(($count + $(echo ${contentvar} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed "s/[^${plus}]//g" | wc -m) - 1))
    count=$(($count - $(echo ${contentvar} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed "s/[^${sub}]//g" | wc -m) + 1))
    if [ $DEBUG == "true" ]; then
        echo "findBrace, at first line count = $count"
    fi
    while [ ${count} -gt 0 ]
    do
        if [ "$direction" == "up" ]; then
            line=$((${line} - 1))
        else
            line=$((${line} + 1))
        fi
        contentvar=$(sed -n "${line}p" ${file})
        count=$(($count + $(echo ${contentvar} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed "s/[^${plus}]//g" | wc -m) - 1))
        count=$(($count - $(echo ${contentvar} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed "s/[^${sub}]//g" | wc -m) + 1))
        if [ $DEBUG == "true" ]; then
            echo -e "\tin while, at line $line, count = $count"
        fi
    done
    GLOBALLINE=$line
}

###############################################################
# END OF FUNCTION
###############################################################

###############################################################
# Function Name: findBlock
# Parameters: $1 type to be find (methodBlock/classBlock/inclassBlock)
#             $2 original file
#             $3 start line where to begin to find the block
#             $4 when we only want STARTLINE, populate this parameter with "startline" 
# Usage: findBlock $FINDTYPE $FILENAME $LINENUMBER ["startline"]
# Author: Gary
# Time: 2013-12-03
###############################################################
function findBlock() {
    local -i LINE=$3
    local -i LINEBACKUP=$3
    local DETECTSUPER="false"
    local DETECTRETURN="false"
    local braceencounter="false"
    local FILE=$2
    local TYPE=$1
    local CONTENTVAR=""
    local -i COUNT=1
    local -i bracelocation=0;
    local ISCOMMENT="false"
    STARTLINE=$LINE
    ENDLINE=$LINE
    if [ "$TYPE" == "methodBlock" ]; then

        if [ $DEBUG == "true" ]; then
            echo "***** Begin to find methodBlock for ($METHODNAME, Singleline = $LINE) *****"
        fi

        CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '[;{]')
        while [ -z "${CONTENTVAR}" ]
        do
            LINE=$((${LINE} + 1))
            CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '[;{]')
            if [ $DEBUG == "true" ]; then
                echo "while 1, find { for methodBlock ($METHODNAME, Line = $LINE)"
            fi
        done
        if [ $DEBUG == "true" ]; then
            echo "Had found out the [{/;] for method $METHODNAME, line = $LINE"
        fi
            
        if [ $LINE -ne $3 ]; then
            METHODNAME=$(echo "${METHODNAME1}()")
        fi

        if [ -z "$(echo ${CONTENTVAR} | grep '{')" ]; then
            ISABSTRACTMETHOD="true"
            STARTLINE=0
            ENDLINE=0
        elif [ ! -z "$(echo $CONTENTVAR | grep '{.*}')" ]; then
            ISSINGLELINEMETHOD="true"
            STARTLINE=0
            ENDLINE=0
        else
            LINEBACKUP=$LINE
            LINE=$((${LINE} + 1))
            CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep -v 'super[[:space:]]*\(.*|this[[:space:]]*\(.*|^$')
            if [ ! -z "$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/\/\/.*//g' | egrep 'super[[:space:]]*\(.*|this[[:space:]]*\(.*')" ]; then
                DETECTSUPER="true"
            fi
            while [ -z "${CONTENTVAR}" -a "$DETECTSUPER" == "false" ]
            do
                LINE=$((${LINE} + 1))
                if [ $DETECTSUPER == "false" ]; then
                    CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep -v 'super[[:space:]]*\(.*|this[[:space:]]*\(.*|^$')
                else
                    CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/""/g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep -v -n 'super[[:space:]]*\(.*|this[[:space:]]*\(.*')
                fi
                if [ $DEBUG == "true" ]; then
                    echo "while 2, try to skip super() or this() or blankline ($METHODNAME, Line = $LINE)"
                fi
                if [ ! -z "$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/\/\/.*//g' | egrep 'super[[:space:]]*\(.*|this[[:space:]]*\(.*')" ]; then
                    DETECTSUPER="true"
                fi
            done
            if [ "$DETECTSUPER" == "false" ]; then
                LINE=$((${LINE} - 1))
            fi
            if [ $DETECTSUPER == "true" -a -z "$(echo $CONTENTVAR | grep '}')" ]; then
                CONTENTVAR=$(sed -n "${LINE}p" $FILE | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep ';[[:space:]]*$')
                while [ -z "$CONTENTVAR" ]
                do
                    if [ ! -z "$(sed -n "${LINE}p" $FILE | sed 's/"[^"]*"//g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '^[^;]*{')" ]; then
                        findBrace rightbrace $FILE $LINE
                        if [ $LINE -ne $GLOBALLINE ]; then
                            LINE=$(($GLOBALLINE - 1))
                        else
                            LINE=$GLOBALLINE
                        fi
                        if [ $DEBUG == "true" ]; then
                            echo "findBrace rightbrace is called for super detect, and had found out } at line = $LINE"
                        fi
                    fi
                    LINE=$((${LINE} + 1))
                    CONTENTVAR=$(sed -n "${LINE}p" $FILE | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep ';[[:space:]]*$')
                    if [ $DEBUG == "true" ]; then
                        echo "while 2-1, super() is defined in multilines, try to find (;) ($METHODNAME, Line = $LINE)"
                    fi
                done
            fi
            DETECTSUPER="false"
            STARTLINE=$LINE
            if [ $DEBUG = "true" ]; then
                echo "startline = $STARTLINE"
            fi
            if [ "$4" == "startline" ]; then
                return
            fi
            LINE=$LINEBACKUP
            findBrace rightbrace $FILE $LINE
            LINE=$GLOBALLINE
            if [ $DEBUG = "true" ]; then
                echo "Had found out } for method $METHODNAME, line = $LINE"
            fi


            LINE=$((${LINE} - 1))
            CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep -v '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*|$)')
            if [ ! -z "$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)')" ]; then
                DETECTRETURN="true"
                LINE=$((${LINE} - 1))
            else
                DETECTRETURN="false"
            fi
            while [ -z "${CONTENTVAR}" -a "$DETECTRETURN" == "false" ]
            do
                LINE=$((${LINE} - 1))
                if [ $DETECTRETURN == "false" ]; then
                    CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep -v '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*|$)')
                else
                    CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep -v -n '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)')
                fi
                if [ $DEBUG == "true" ]; then
                    echo "while 4, try to skip return or blankline ($METHODNAME, Line = $LINE)"
                fi
                if [ ! -z "$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)')" ]; then
                    DETECTRETURN="true"
                    LINE=$((${LINE} - 1))
                else
                    DETECTRETURN="false"
                fi
            done
            ##### add grep -v 'return'
            if [ $LINE -eq $LINEBACKUP -a $DETECTRETURN == "false" ]; then
                LINE=$(($GLOBALLINE - 1))
                UNREACHEDABLE="false"
            else
                if [ "$DETECTRETURN" == "true" -o ! -z "$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep ';[[:space:]]*$' | grep -v 'return')" ]; then
                    UNREACHEDABLE="false"
                else
                    UNREACHEDABLE="unknow"
                fi

                if [ -z "$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '}' | grep -v ';[[:space:]]*$')" -a $DETECTRETURN == "false" ]; then
                    if [ ! -z "$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '[})].*;[[:space:]]*$')" ]; then
                        bracelocation=$LINE
                        braceencounter="true"
                        if [ ! -z "$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep ')[^}]*;[[:space:]]*$')" ]; then
                            if [ $DEBUG == "true" ]; then
                                echo "Begin to find ( from line $LINE"
                            fi
                            findBrace leftparentheses $FILE $LINE
                        else
                            if [ $DEBUG == "true" ]; then
                                echo "Begin to find } from line $LINE"
                            fi
                            findBrace leftbrace $FILE $LINE
                        fi
                        LINE=$GLOBALLINE
                        if [ $DEBUG == "true" ]; then
                            echo "Had found out (/{ at line $LINE"
                        fi
                    fi
                    COUNT=1
                    LINE=$((${LINE} - 1))
                    CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' |  egrep '[;}][[:space:]]*$|{')
                    while [ -z "${CONTENTVAR}" ]
                    do
                        LINE=$((${LINE} - 1))
                        COUNT=$((${COUNT} + 1))
                        CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' |  egrep '[;}][[:space:]]*$|{')
                        if [ $DEBUG == "true" ]; then
                            echo "while 5, a statement with multilines, keep searching to determine if it is a return statement ($METHODNAME, Line = $LINE)"
                        fi
                    done
                    LINE=$((${LINE} + 1))
                    COUNT=$(($COUNT - 1))
                    CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -v '^[[:space:]]*$')
                    while [ -z "$CONTENTVAR" ]
                    do
                        LINE=$(($LINE + 1))
                        COUNT=$(($COUNT - 1))
                        CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g')
                    done
                    CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)')
                    if [ -z "$CONTENTVAR" ]; then
                        LINE=$(($LINE + $COUNT))
                        if [ "$braceencounter" == "true" ]; then
                            LINE=$bracelocation
                            braceencounter="false"
                        fi
                    else
                        LINE=$(($LINE - 1))
                    fi
                fi
            fi
            LINE=$((${LINE} + 1))
            ENDLINE=$((${LINE} + 1))
            if [ $DEBUG == "true" ]; then
                echo "methodBlock determined successed ($METHODNAME): startline = $STARTLINE, endline = $ENDLINE"
            fi
        fi
    elif [ "$TYPE" == "classBlock" ]; then
        if [ $DEBUG == "true" ]; then
            echo "***** Begin to find classBlock for ($PRIVATECLASS, Singleline = $LINE) *****"
        fi
        CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '{')
        while [ -z "${CONTENTVAR}" ]
        do
            LINE=$((${LINE} + 1))
            CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '{')
            if [ $DEBUG == "true" ]; then
                echo "while 6, find { for classBlock ($PRIVATECLASS, Line = $LINE)"
            fi
        done
        STARTLINE=$LINE
        if [ $DEBUG == "true" ]; then
            echo "(startline for this class is $STARTLINE)"
        fi
        if [ "$4" == "startline" ]; then
            return
        fi
        findBrace rightbrace $FILE $LINE
        LINE=$GLOBALLINE
        ENDLINE=$LINE
        if [ $DEBUG == "true" ]; then
            echo "classBlock determined successed ($PRIVATECLASS): Startline = $STARTLINE, Endline = $ENDLINE"
        fi
    elif [ "$TYPE" == "inclassBlock" ]; then
        CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '}')
        while [ -z "$CONTENTVAR" ]
        do
            LINE=$(($LINE + 1))
            CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '}')
            if [ $DEBUG == "true" ]; then
                echo "findBlock(inclassBlock) while 13, find } for inclassBlock (Line = $LINE)"
            fi
        done
        ENDLINE=$LINE
        findBrace leftbrace $FILE $LINE
        LINE=$GLOBALLINE
        LINE=$(($LINE - 1))
        CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -v '^[[:space:]]*$' | egrep '[;}][[:space:]]*$|{')
        while [ -z "$CONTENTVAR" ]
        do
            LINE=$(($LINE - 1))
            CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -v '^[[:space:]]*$' | egrep '[;}][[:space:]]*$|{')
        done
        LINE=$(($LINE + 1))
        CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -v '^[[:space:]]*$')
        while [ -z "$CONTENTVAR" ]
        do
            LINE=$(($LINE + 1))
            CONTENTVAR=$(sed -n "${LINE}p" ${FILE} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g')
        done
        STARTLINE=$LINE
    fi
}
###############################################################
# End of function
###############################################################

MESSAGE1="*****##### There are more than one prototypes for this method, try to locate this method, but maybe wrong! #####*****\n"
MESSAGE2="*****##### There is no matched parttern for this method, something is wrong, please check it! #####*****\n"
MESSAGE3="*****##### This is an abstract method, so do nothing... #####*****\n"
MESSAGE4="*****##### This is a singleline method, so do nothing... #####*****\n"
MESSAGE5="*****##### This method is defined at line "
###############################################################
# Function Name: PrintMessage
# Parameters: $1 which message to print
# Usage: PrintMessage msg1
# Author: Gary
# Time: 2013-12-03
###############################################################
function PrintMessage() {
    local CONSTRUCTORPREFIX
    if [ "$ISCONSTRUCTOR" == "true" ]; then
        CONSTRUCTORPREFIX="[Constructor] "
    else
        CONSTRUCTORPREFIX=""
    fi
    local msg
    if [ $1 = "msg1" ]; then
        msg="$MESSAGE1\t\t$2"
        tput setf 4
    elif [ $1 = "msg2" ]; then
        msg=$MESSAGE2
        tput setf 4
    elif [ $1 = "msg3" ]; then
        msg=$MESSAGE3
        tput setf 3
    elif [ $1 = "msg4" ]; then
        msg=$MESSAGE4
        tput setf 5
    elif [ $1 = "msg5" ]; then
        msg="${MESSAGE5}${SINGLELINE} in the original source file #####*****\n"
        tput setf 2
    else
        tput setf 2
    fi
    
    if [ $DEBUG == "true" ]; then
        echo -e "${count}\tFilename = ${FILENAME}"
        echo -e "\tClassname = ${CLASSNAME}"
        echo -e "\tMethodname = ${CONSTRUCTORPREFIX}${METHODNAME}"
        echo -e "\tGreppattern = \"${GREPPAT}\""
        echo -e "\tMatchedLines = ${WL}"
        echo -e "$msg"
    fi
    tput setf 7
}
###############################################################
# End of function
###############################################################

###############################################################
# Function Name: filehandle
# Parameters: $1 the original file
# Usage: checkLastCodeBlock $file $line "notfirstcall"
# Author: Gary
# Time: 2013-12-16
###############################################################
function filehandle() {
    declare -i wl
    declare -i lineoffile
    declare -i localstartline
    declare -i localendline
    declare file
    declare line
    declare contentvar
    declare filehandletmpfile
    file=$1
    filehandletmpfile=/tmp/${FILENAME%.*}_filehandletmpfile

    sed -i 's/"[^"]*"/" "/g' $file
    sed -i 's/\/\/.*//g' $file
    sed -i '/^[[:space:]]*$/d' $file
    ##### add here
    sed -i "s/'.'//g" $file
    ##### end here

    wl=$(sed -n '1,$p' $file | sed 's/_hejinyi.*hejinyi_//g' | grep '}.*;[[:space:]]*$' | grep -v 'hejinyi' | wc -l | awk '{print $1}')
    while [ $wl -ne 0 ]
    do
        line=$(sed -n '1,$p' $file | sed 's/_hejinyi.*hejinyi_//g' | grep -n '}.*;[[:space:]]*$' | grep -v 'hejinyi' | sed -n '$p' | cut -d ':' -f 1)
        findBlock "inclassBlock" $file $line
        localstartline=$(($STARTLINE - 1))
        localendline=$(($ENDLINE + 1))
        sed -n "1,${localstartline}p" $file > $filehandletmpfile
        contentvar=$(sed -n "${STARTLINE},${ENDLINE}p" $file)
        echo $contentvar >> $filehandletmpfile
        sed -n "${localendline},\$p" $file >> $filehandletmpfile
        cp $filehandletmpfile $file
        sed -i "${STARTLINE}s/$/hejinyi/g" $file
        wl=$(sed -n '1,$p' $file | sed 's/_hejinyi.*hejinyi_//g' | grep '}.*;[[:space:]]*$' | grep -v 'hejinyi' | wc -l | awk '{print $1}')
    done
    ######## add here
    sed -i 's/hejinyi//g' $file
    declare -i count
    
    wl=$(sed -n '1,$p' $file | sed 's/_hejinyi.*hejinyi_//g' | grep ')[[:space:]]*;[[:space:]]*$' | grep -v 'hejinyi' | wc -l | awk '{print $1}')
    while [ $wl -ne 0 ]
    do
        line=$(sed -n '1,$p' $file | sed 's/_hejinyi.*hejinyi_//g' | grep -n ')[[:space:]]*;[[:space:]]*$' | grep -v 'hejinyi' | sed -n '$p' | cut -d ':' -f 1)
        count=0
        contentvar=$(sed -n "${line}p" $file)
        count=$(($count + $(echo ${contentvar} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed "s/)//g" | wc -m) - 1))
        count=$(($count - $(echo ${contentvar} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed "s/(//g" | wc -m) + 1))
        if [ $count -eq 0 -o $line -eq 1 ]; then
            sed -i "${line}s/$/hejinyi/g" $file
            wl=$(sed -n '1,$p' $file | grep ')[[:space:]]*;[[:space:]]*$' | grep -v 'hejinyi' | wc -l | awk '{print $1}')
            continue
        fi
        ENDLINE=$line
        findBrace leftparentheses $file $line
        line=$(($line - 1))
        contentvar=$(sed -n "${line}p" ${file} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -v '^[[:space:]]*$' | egrep '[;}][[:space:]]*$|{')
        while [ -z "$contentvar" ]
        do
            line=$(($line - 1))
            contentvar=$(sed -n "${line}p" ${file} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -v '^[[:space:]]*$' | egrep '[;}][[:space:]]*$|{')
        done
        line=$(($line + 1))
        contentvar=$(sed -n "${line}p" ${file} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -v '^[[:space:]]*$')
        while [ -z "$contentvar" ]
        do
            line=$(($line + 1))
            contentvar=$(sed -n "${line}p" ${file} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g')
        done
        STARTLINE=$line
        localstartline=$(($STARTLINE - 1))
        localendline=$(($ENDLINE + 1))
        sed -n "1,${localstartline}p" $file > $filehandletmpfile
        contentvar=$(sed -n "${STARTLINE},${ENDLINE}p" $file)
        echo $contentvar >> $filehandletmpfile
        sed -n "${localendline},\$p" $file >> $filehandletmpfile
        cp $filehandletmpfile $file
        sed -i "${STARTLINE}s/$/hejinyi/g" $file
        wl=$(sed -n '1,$p' $file | grep ')[[:space:]]*;[[:space:]]*$' | grep -v 'hejinyi' | wc -l | awk '{print $1}')
    done
    ######## end here
    sed -i 's/hejinyi//g' $file
    sed -i 's/^[[:space:]]*return.*;[[:space:]]*$/return;/g' $file
    sed -i 's/^[[:space:]]*if[[:space:]]*.*return.*;[[:space:]]*$/if(){return;}/g' $file
    sed -i 's/^[[:space:]]*else[[:space:]]*if[[:space:]]*.*return.*;[[:space:]]*$/else if(){return;}/g' $file
    sed -i 's/^[[:space:]]*else[[:space:]]*.*return.*;[[:space:]]*$/else {return;}/g' $file
    sed -i '/}.*;/s/[}{]//g' $file
    sed -i 's/[}{]/\n&\n/g' $file
    sed -i '/^[[:space:]]*$/d' $file
}

###############################################################
# End of function
###############################################################

###############################################################
# Function Name: findPreviousRightBrace
# Parameters: $1 the original file
#             $2 where to begin to find
# Usage: findPreviousRightBrace $file $line
# Author: Gary
# Time: 2013-12-16
###############################################################
function findPreviousRightBrace() {
    local -i line
    local file
    local contentvar

    line=$2
    file=$1

    line=$(($line - 1))
    contentvar=$(sed -n "${line}p" $file | grep '}' | grep -v '}.*;[[:space:]]*$')
    while [ -z "$contentvar" -a $line -gt 1 ]
    do
        line=$(($line - 1))
        contentvar=$(sed -n "${line}p" $file | grep '}' | grep -v '}.*;[[:space:]]*$')
        if [ $DEBUG == "true" ]; then
            echo "findPreviousRightBrace while 1, line = $line"
        fi
    done
    GLOBALLINE=$line
}

###############################################################
# End of function
###############################################################

###############################################################
# Function Name: findPreviousRightBrace
# Parameters: $1 the original file
#             $2 where to begin to find
#             $3 find if or try
# Usage: findDeadline $file $line "if"
# Author: Gary
# Time: 2013-12-16
###############################################################
function findDeadline() {
    local file
    local -i line
    local contentvar
    local typetofind

    file=$1
    line=$2
    typetofind=$3

    if [ $DEBUG == "true" ]; then
        echo "begin findDeadline(), from line $line"
    fi
    findPreviousRightBrace $file $line
    line=$GLOBALLINE
    findBlock inclassBlock $file $line
    line=$STARTLINE
    if [ "$typetofind" == "if" ]; then
        contentvar=$(sed -n "${line}p" $file | egrep -v 'else[[:space:]]+if' | grep 'if[[:space:]]*(.')
    else
        contentvar=$(sed -n "${line}p" $file | egrep '[[:space:]]*try[[:space:]]*')
    fi
    while [ -z "$contentvar" ]
    do
        findPreviousRightBrace $file $line
        line=$GLOBALLINE
        findBlock inclassBlock $file $line
        line=$STARTLINE
        if [ "$typetofind" == "if" ]; then
            contentvar=$(sed -n "${line}p" $file | egrep -v 'else[[:space:]]+if' | grep 'if[[:space:]]*(.')
        else
            contentvar=$(sed -n "${line}p" $file | egrep '[[:space:]]*try[[:space:]]*')
        fi
        if [ $DEBUG == "true" ]; then
            echo "findDeadline line = $line, haven't find if () or try {, keep searching..."
        fi
    done
    GLOBALLINE=$line
    if [ $DEBUG == "true" ]; then
        echo "leave findDeadline(), Globalline = $GLOBALLINE"
    fi
}
###############################################################
# End of function
###############################################################

###############################################################
# Function Name: checkLastCodeBlock
# Parameters: $1 the original file
#             $2 the line we want to check if it is reachedable
#                when used for resure call inside the function
#                itself, this line must contain '}', but in our
#                script, the line should be the last line of $1
#                line
#             $3 indicates whether it is resure called, when 
#                used in our script, it should be "firstcall",
#                while in resure call inside the function itself
#                , it can be anyother words except "firstcall"
# Usage: checkLastCodeBlock $file $line "notfirstcall"
# Author: Gary
# Time: 2013-12-15
###############################################################
#checkLastCodeBlock $file $line "notfirstcall"
#
function checkLastCodeBlock() {
    declare countbraces=0
    declare contentvar
    declare detectelse="false"
    declare detectcatch="false"
    declare file
    declare -i line
    declare -i currentdeadline=0
    declare -i startlinebackup=0
    declare -i endlinebackup=0
    declare type="notfirstcall"
    file=$1
    if [ "$3" == "firstcall" ]; then
        filehandle $file
        line=$(wc -l $1 | awk '{print $1}')
        contentvar=$(sed -n "${line}p" $file | grep '}')
        while [ -z "$contentvar" ]
        do
            line=$(($line - 1))
            if [ $line -lt 1 ]; then
                tput setf 4
                echo "!!!!!!!!!! There is a mistake when handle method $METHODNAME (in block: $STARTLINE-$ENDLINE) in file $ORGDIR/$FILENAME, please check it"
                tput setf 7
                return
            fi
            contentvar=$(sed -n "${line}p" $file | grep '}')
            if [ $DEBUG == "true" ]; then
                echo "checkLastCodeBlock while 1, line = $line"
            fi
        done
    else
        line=$2
    fi
    if [ $DEBUG == "true" ]; then
        echo "checkLastCodeBlock , line = $line"
    fi

    findBlock inclassBlock $file $line
    STARTLINEFORCHECKREACHEDABLE=$STARTLINE
    ENDLINEFORCHECKREACHEDABLE=$ENDLINE
    countbraces=$(sed -n "${STARTLINEFORCHECKREACHEDABLE},${ENDLINEFORCHECKREACHEDABLE}p" $file | grep '}' | grep -v '}.*;[[:space:]]*$' | wc -l)
    if [ $DEBUG == "true" ]; then
        echo "checkLastCodeBlock: startline = $STARTLINEFORCHECKREACHEDABLE, endline = $ENDLINEFORCHECKREACHEDABLE"
    fi

    if [ ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | grep '[[:space:]]*while[[:space:]]*([[:space:]]*true[[:space:]]*)')" ]; then
        if [ $DEBUG == "true" ]; then
            echo "checkLastCodeBlock return, because encounter while(true), it is a infinite loop"
        fi
        UNREACHEDABLE="true"
        return
    elif [ ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | egrep '[[:space:]]*switch[[:space:]]*')" ]; then
        if [ $DEBUG == "true" ]; then
            echo "checkLastCodeBlock return, because encounter switch statement, can't handle"
        fi
        if [ -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE},${ENDLINEFORCHECKREACHEDABLE}p" $file | grep 'default[[:space:]]*:')" -o ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE},${ENDLINEFORCHECKREACHEDABLE}p" $file | grep 'break[[:space:]]*;')" ]; then
            UNREACHEDABLE="false"
        else
            UNREACHEDABLE="true"
        fi
        return
    elif [ -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE},${ENDLINEFORCHECKREACHEDABLE}p" $file | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/\/\/.*//g' | egrep '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)')" ]; then
        if [ -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | grep 'finally')" ]; then
            UNREACHEDABLE="false"
            if [ $DEBUG == "true" ]; then
                echo "checkLastCodeBlock return, because there is no return statement in a block."
            fi
            return
        else
            if [ -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE},${ENDLINEFORCHECKREACHEDABLE}p" $file | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/\/\/.*//g' | egrep '\.close\(.*\)|\.endTransaction\(.*\)')" ]; then
                UNREACHEDABLE="false"
                if [ $DEBUG == "true" ]; then
                    echo "checkLastCodeBlock return, because there is a return statement in finally{}."
                fi
                return
            else
                UNREACHEDABLE="true"
                return
            fi
        fi
    elif [ ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | egrep -v 'else[[:space:]]+if' | egrep 'if[[:space:]]*\(.|[[:space:]]*try[[:space:]]*')" ]; then
            if [ "$3" == "firstcall" -o "$3" == "againfirstcall" ]; then
                UNREACHEDABLE="false"
                return
            fi
    elif [ -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | egrep 'else|catch|finally')" ]; then
        UNKNOWTYPE="true"
        if [ $DEBUG == "true" ]; then
            echo "in firstcall detect unknow type, Unknowtype is set to $UNKNOWTYPE"
        fi
    fi
    if [ $countbraces -eq 1 ]; then
        if [ ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | grep 'else')" ]; then
            while [ -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | grep 'if[[:space:]]*.' | egrep -v 'else[[:space:]]+if')" ]
            do
                findPreviousRightBrace $file $STARTLINEFORCHECKREACHEDABLE
                line=$GLOBALLINE
                if [ $DEBUG == "true" ]; then
                    echo "checkLastCodeBlock while 4, line = $line, Deadlineforcheck = $DEADLINEFORCHECK"
                    echo "detectelse = $detectelse"
                fi
                if [ $line -eq 1 ]; then
                    tput setf 4
                    echo "----------run into error when checklastcodeblock for method ($METHODNAME) of file $ORIGINALFILENAME"
                    tput setf 7
                    UNREACHEDABLE="false"
                    return
                fi
                checkLastCodeBlock $file $line "notfirstcall"
                if [ $UNREACHEDABLE == "false" ]; then
                    return
                fi
            done
            return
        elif [ ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | egrep 'catch')" ]; then
            while [ -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | grep '[[:space:]]*try[[:space:]]*')" ]
            do
                findPreviousRightBrace $file $STARTLINEFORCHECKREACHEDABLE
                line=$GLOBALLINE
                if [ $DEBUG == "true" ]; then
                   echo "checkLastCodeBlock while 6, line = $line"
                fi
                if [ $line -eq 1 ]; then
                    tput setf 4
                    echo "----------run into error when checklastcodeblock for method ($METHODNAME) of file $ORIGINALFILENAME"
                    tput setf 7
                    UNREACHEDABLE="false"
                    return
                fi
                checkLastCodeBlock $file $line "notfirstcall"
                if [ $UNREACHEDABLE == "false" ]; then
                    return
                fi
            done
            return
        elif [ ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | egrep 'finally')" ]; then
            if [ ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE},${ENDLINEFORCHECKREACHEDABLE}p" $file | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/\/\/.*//g' | egrep '\.close\(.*\)|\.endTransaction\(.*\)')" ]; then
                UNREACHEDABLE="true"
                if [ $DEBUG == "true" ]; then
                    echo "checkLastCodeBlock return, because there is a return statement in finally{}."
                fi
                return
            else
                while [ -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | grep '[[:space:]]*try[[:space:]]*')" ]
                do
                    findPreviousRightBrace $file $STARTLINEFORCHECKREACHEDABLE
                    line=$GLOBALLINE
                    if [ $DEBUG == "true" ]; then
                       echo "checkLastCodeBlock while 6, line = $line"
                    fi
                    if [ $line -eq 1 ]; then
                        tput setf 4
                        echo "----------run into error when checklastcodeblock for method ($METHODNAME) of file $ORIGINALFILENAME"
                        tput setf 7
                        UNREACHEDABLE="false"
                        return
                    fi
                    checkLastCodeBlock $file $line "notfirstcall"
                    if [ $UNREACHEDABLE == "false" ]; then
                        return
                    fi
                done
                return
            fi
        elif [ ! -z "$(sed -n "${STARTLINEFORCHECKREACHEDABLE}p" $file | egrep -v 'else[[:space:]]+if' | egrep 'if[[:space:]]*\(.|[[:space:]]*try[[:space:]]*')" ]; then
                UNREACHEDABLE="true"
                return
        else
            UNREACHEDABLE="true"
            UNDETECTED="true"
            return
        fi
    else
        if [ $DEBUG == "true" ]; then
            echo "mutibracesblock, bracesstartline = $STARTLINEFORCHECKREACHEDABLE, bracesendline = $ENDLINEFORCHECKREACHEDABLE, bracessum = $countbraces"
        fi
        line=$(($ENDLINEFORCHECKREACHEDABLE - 1))
        contentvar=$(sed -n "${line}p" $file | grep '}' | grep -v '}.*;[[:space:]]*$')
        while [ -z "$contentvar" ]
        do
            if [ ! -z "$(sed -n "${line}p" $file | grep ';[[:space:]]*$')" ]; then
                declare -i innerline=$line
                if [ ! -z "$(sed -n "${line}p" $file | grep '}')" ]; then
                    findBrace leftbrace $file $innerline
                    innerline=$GLOBALLINE
                fi
                innerline=$(($innerline - 1))
                contentvar=$(sed -n "${innerline}p" $file | egrep -n '[;}][[:space:]]*$|{|^$')
                while [ -z "$contentvar" ]
                do
                    innerline=$(($innerline - 1))
                    contentvar=$(sed -n "${innerline}p" $file | egrep -n '[;}][[:space:]]*$|{|^$')
                    if [ $DEBUG == "true" ]; then
                        echo "checkLastCodeBlock while 10, line = $line"
                    fi
                done
                innerline=$(($innerline + 1))
                contentvar=$(sed -n "${innerline}p" ${file} | egrep '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)')
                if [ -z "$contentvar" ]; then
                    if [ $DEBUG == "true" ]; then
                        echo "checkLastCodeBlock return, because encountered an unreturn statement."
                    fi
                    UNREACHEDABLE="false"
                    return
                else
                    UNREACHEDABLE="true"
                    return
                fi
            fi
            line=$(($line - 1))
            contentvar=$(sed -n "${line}p" $file | grep '}' | grep -v '}.*;[[:space:]]*$')
            if [ $DEBUG == "true" ]; then
                echo "checkLastCodeBlock while 11, line = $line"
            fi
        done
            if [ $DEBUG == "true" ]; then
                echo "checkLastCodeBlock while 11-2, found '}' for new block at line = $line"
            fi
        if [ "$UNKNOWTYPE" == "true" ]; then
            type="againfirstcall"
            UNKNOWTYPE="false"
            if [ $DEBUG == "true" ]; then
                echo "resucre call type of checkreachedable is set to $type"
            fi
        else
            type="notfirstcall"
        fi
        if [ $DEBUG == "true" ]; then
            echo "checkLastCodeBlock call checkLastCodeBlock again, line = $line (})"
        fi
        startlinebackup=$STARTLINEFORCHECKREACHEDABLE
        endlinebackup=$ENDLINEFORCHECKREACHEDABLE
        checkLastCodeBlock $file $line $type
        STARTLINEFORCHECKREACHEDABLE=$startlinebackup
        ENDLINEFORCHECKREACHEDABLE=$endlinebackup
    fi
}
###############################################################
# End of function
###############################################################

###############################################################
# Function Name: addLogToMethod
# Parameters: $1 which file to write the Log.d() at the entrance
#             and exit of the method according to STARTLINE and
#             ENDLINE that returned by function findBlock()
# Usage: addLogToMethod $FILENAME
# Author: Gary
# Time: 2013-12-06
###############################################################
function addLogToMethod() {
    local CONSTRUCTORPREFIX
    local -i RETURNCOUNT
    local -i LINE
    local -i LINEBACKUP
    local CONTENTVAR
    local -i wl
    if [ "$ISCONSTRUCTOR" == "true" ]; then
        CONSTRUCTORPREFIX="[Constructor] "
    else
        CONSTRUCTORPREFIX=""
    fi
    if [ ${ISABSTRACTMETHOD} == "true" ]; then
        if [ "$DEBUG" == "true" ]; then
            PrintMessage msg3
        fi
        ISABSTRACTMETHOD="false"
    elif [ ${ISSINGLELINEMETHOD} == "true" ]; then
        if [ "$DEBUG" == "true" ]; then
            PrintMessage msg4
        fi
        ISSINGLELINEMETHOD="false"
    else
        # workoutIndent $ORGDIR/$FILENAME $STARTLINE
        workoutIndent $1 $STARTLINE
        sed -i "${STARTLINE}a ${PREFIX}Log.d(${TAG}, \"$LOGPREFIX Enter<garymethodline> ${CONSTRUCTORPREFIX}${CLASSNAME}.${METHODNAME} $LOGSUFFIX\");" $1
        sed -i "${ENDLINE}i ${PREFIX}Log.d(${TAG}, \"$LOGPREFIX Leave<garymethodline> ${CONSTRUCTORPREFIX}${CLASSNAME}.${METHODNAME} $LOGSUFFIX\");" $1

        ############ add from here
        wl=$(sed -n "${STARTLINE},${ENDLINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep '(if|else|else[[:space:]]+if).*[[:space:]]+(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)' | wc -l)
        while [ $wl -ne 0 ]
        do
            wl=$(sed -n "${STARTLINE},${ENDLINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep -n '(if|else|else[[:space:]]+if).*[[:space:]]+(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)' | sed -n '$p' | cut -d ':' -f 1)
            wl=$(($STARTLINE + $wl - 1))
            if [ $DEBUG == "true" ]; then
                sed -n "${wl}p" $1
            fi
            workoutIndent $1 $wl
            PREFIX=$(echo "${PREFIX}MYPREFIXMYPREFIXMYPREFIXMYPREFIX")
            sed -i "${wl}s/return/\/\/new line by LogHelpler for return\n${PREFIX}return/g" $1
            sed -i "${wl}s/throw/\/\/new line by LogHelpler for return\n${PREFIX}throw/g" $1
            ENDLINE=$(($ENDLINE + 1))
            wl=$(sed -n "${STARTLINE},${ENDLINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep '(if|else|else[[:space:]]+if).*[[:space:]]+(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)' | wc -l)
        done
        sed -i '/^MYPREFIX/s/MYPREFIX/ /g' $1
        ########## add end here

        RETURNCOUNT=$(sed -n "${STARTLINE},${ENDLINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)' | wc -l)
        if [ $DEBUG == "true" ]; then
            echo "addLogToMethod: find $RETURNCOUNT inner return from $STARTLINE to $ENDLINE"
        fi

        declare -i localcount=0
        while [ $localcount -ne $RETURNCOUNT ]
        do
            if [ -z "$(sed -n "${STARTLINE},${ENDLINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)')" ]; then
                localcount=$(($localcount + 1))
                continue
            fi
            LINE=$(sed -n "${STARTLINE},${ENDLINE}p" $1 | egrep -n '^[[:space:]]*(return([[:space:]]+|[[:space:]]*[;\({])|throw[[:space:]]+.*)' | sed -n '1p' | cut -d ':' -f 1)
            LINE=$(($STARTLINE + $LINE - 1))
            LINEBACKUP=$LINE
            LINE=$(($LINE - 1))
            CONTENTVAR=$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"//g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g')
            while [ -z "$CONTENTVAR" ]
            do
                LINE=$(($LINE - 1))
                CONTENTVAR=$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"//g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g')
            done
            if [ -z "$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"//g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep '[;}][[:space:]]*$|{|case.*:|default:[[:space:]]*')" ]; then
                LINE=$LINEBACKUP
                workoutIndent $1 $LINE
                sed -i "${LINE}i ${PREFIX}{\t// added by LogHelpler from gary -$(date +%F) $(date +%T)-" $1
                LINE=$(($LINE + 1))
                LINEBACKUP=$LINE
                ENDLINE=$(($ENDLINE + 1))
                CONTENTVAR=$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"//g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '[{]')
                if [ ! -z "$(echo $CONTENTVAR | grep '{')" ]; then
                    findBrace rightbrace $1 $LINE
                    LINE=$GLOBALLINE
                fi
                CONTENTVAR=$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"//g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep ';[[:space:]]*$')
                while [ -z "$CONTENTVAR" ]
                do
                    if [ ! -z "$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"//g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep '^[^;]*{')" ]; then
                        findBrace rightbrace $1 $LINE
                        if [ $LINE -ne $GLOBALLINE ]; then
                            LINE=$GLOBALLINE
                            LINE=$(($LINE - 1))
                        else
                            LINE=$GLOBALLINE
                        fi
                    fi
                    LINE=$(($LINE + 1))
                    CONTENTVAR=$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"//g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep ';[[:space:]]*$')
                done
                sed -i "${LINE}a ${PREFIX}}\t// added by LogHelpler from gary -$(date +%F) $(date +%T)-" $1
                ENDLINE=$(($ENDLINE + 1))
            fi
            LINE=$LINEBACKUP
            localcount=$(($localcount + 1))
            if [ $DEBUG == "true" ]; then
                echo "addLogToMethod: handle return of $METHODNAME at line $LINE($localcount/$RETURNCOUNT)"
            fi
            sed -i "${LINE}s/return/garyturn/g" $1
            sed -i "${LINE}s/throw/garythrow/g" $1
            workoutIndent $1 $LINE
            sed -i "${LINE}i ${PREFIX}Log.d(${TAG}, \"$LOGPREFIX Leave<garymethodline> ${CLASSNAME}.${METHODNAME} $LOGSUFFIX\");" $1
            ENDLINE=$(($ENDLINE + 1))
        done
        sed -i '/garyturn/s/garyturn/return/g' $1
        sed -i '/garythrow/s/garythrow/throw/g' $1

        if [ $RETURNCOUNT -gt 0 ]; then
            if [ $DEBUG == "true" ]; then
                echo "Returncount = $RETURNCOUNT"
            fi
            if [ $UNREACHEDABLE == "unknow" ]; then
                declare tmpcheckreachedablefile="/tmp/${FILENAME%.*}_checkreachedablefile"
                local -i checkreachedableWL
                if [ ! -f $tmpcheckreachedablefile ]; then
                    touch $tmpcheckreachedablefile
                fi
                STARTLINEBACKUP=$STARTLINE
                ENDLINEBACKUP=$ENDLINE
                STARTLINE=$(($STARTLINE + 1))
                sed -n "${STARTLINE},${ENDLINE}p" $1 > $tmpcheckreachedablefile
                checkreachedableWL=$(wc -l $tmpcheckreachedablefile | awk '{print $1}')
            
                if [ $DEBUG == "true" ]; then
                    echo "checkLastCodeBlock is called"
                fi
                checkLastCodeBlock $tmpcheckreachedablefile $checkreachedableWL "firstcall"
                if [ $DEBUG == "true" ]; then
                    echo "checkLastCodeBlock is finished"
                fi
                # rm -f $tmpcheckreachedablefile
                unset tmpcheckreachedablefile
                unset checkreachedableWL
                STARTLINE=$STARTLINEBACKUP
                ENDLINE=$ENDLINEBACKUP
            fi
            if [ $UNREACHEDABLE == "unknow" ]; then
                sed -i "${ENDLINE}s/${LOGPREFIX} Leave/${LOGPREFIX} maybeunreachedableLeave/g" $1
            elif [ $UNREACHEDABLE == "true" ]; then
                sed -i "${ENDLINE}d" $1
                if [ "$UNDETECTED" == "true" ]; then
                    sed -i "${ENDLINE}i ${PREFIX}// added by LogHelpler from gary -undetected branch-" $1
                    UNDETECTED="false"
                else
                    sed -i "${ENDLINE}i ${PREFIX}// added by LogHelpler from gary -an unreachedable location-" $1
                fi
            fi
        fi
        UNREACHEDABLE="unknow"
        if [ "$DEBUG" == "true" ]; then
            PrintMessage msg5
        fi
    fi
}
###############################################################
# End of function 
###############################################################

###############################################################
# Function Name: workoutIndent
# Parameters: $1 the original file
#             $2 which line to write the Log.d() at the entrance
#             and exit of the method according to STARTLINE and
#             ENDLINE return by function findBlock
# Usage: workoutIndent $LINENUMBER
# Author: Gary
# Time: 2013-12-08
###############################################################
function workoutIndent() {
    local LINE
    local LOCALCONTENTVAR
    local -i COUNTS
    PREFIX=""
    LINE=$2
    LOCALCONTENTVAR=$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed '/^$/d')
    while [ -z "$LOCALCONTENTVAR" ]
    do
        LINE=$(($LINE + 1))
        LOCALCONTENTVAR=$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed '/^$/d')
        if [ $DEBUG == "true" ]; then
            echo "while 8, try to workout the Indent for line $2 (Tomethod: $METHODNAME, Line = $LINE)"
        fi
    done

    COUNTS=$(($(sed -n "${LINE}p" $1 | sed 's/[^[:space:]]/a/g' | sed 's/$/aend/g' | sed 's/a.*end//g' | wc -m) - 1))
    if [ ! -z "$(sed -n "${LINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -v 'new .*(.* {' | grep '{')" ]; then
        COUNTS=$(($COUNTS + 4))
        if [ $DEBUG == "true" ]; then
            echo "additional 4 whitespaces is added, because we count the whitespace of a definition of a method"
        fi
    fi
    while [ $COUNTS -ne 0 ]
    do
        PREFIX=$(echo "${PREFIX}MYPREFIX")
        COUNTS=$(($COUNTS - 1))
    done
}
###############################################################
# End of function 
###############################################################

# Deal with one method at one time
if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
    tput setf 3
    echo -e "\nFirst step (1/4): Deal with normal method ($LINESOFMETHODFILE methods, including methods of inner class)."
    tput setf 7
    TASKFINISHEDOLD=0
    TASKFINISHEDNEW=0
    if [ $LINESOFMETHODFILE -eq 0 ]; then
        PROBARSTEP=10
        if [ $DEBUG == "false" -a $RECURSION -eq 0 ]; then
            updateProBar 100
        fi
    else
        PROBARSTEP=$((200 / $LINESOFMETHODFILE))
        if [ $PROBARSTEP -lt 1 ]; then
            PROBARSTEP=1
        elif [ $PROBARSTEP -gt 2 -a $PROBARSTEP -lt 5 ]; then
            PROBARSTEP=4
        elif [ $PROBARSTEP -gt 5 ]; then
            PROBARSTEP=10
        fi
    fi
fi
count=1

while [ $count -le $LINESOFMETHODFILE ]
do
    if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
        TASKFINISHEDNEW=$(($count * 100 / $LINESOFMETHODFILE / $PROBARSTEP))
        if [ $TASKFINISHEDOLD -ne $TASKFINISHEDNEW ]; then
            TASKFINISHEDOLD=$TASKFINISHEDNEW
            TASKFINISHEDNEW=$(($TASKFINISHEDNEW * $PROBARSTEP))
            updateProBar $TASKFINISHEDNEW
        fi
    fi
    # Get the class name, the method name, and generate the grep pattern
    ONELINE=$(sed -n "${count}p" ${METHODFILE})
    CLASSNAME=$(echo ${ONELINE#*:} | awk '{print $1}')
    CLASSNAME=$(echo ${CLASSNAME} | awk '{print $1}')
    if [ "$CLASSNAME" != "${FILENAME%.*}" -a "$CLASSNAME" != "${FILENAME%%_*}" ]; then
        CLASSNAME=$(echo ${CLASSNAME} | tr '.' '$')
    fi
    CLASSNAMECOLLECTION=$(echo "$CLASSNAMECOLLECTION $(echo ${CLASSNAME} | tr '$' ' ')")

    if [ -z "$(echo $CLASSNAME | grep '$')" ]; then
        PRIVATECLASS=$CLASSNAME
    else
        PRIVATECLASS=${CLASSNAME##*$}
    fi
    if [ ! -z "$(echo $ONELINE | grep 'interface')" ]; then
        ISINTERFACE="true"
        ISCLASS="false"
    else
        ISCLASS="true"
        ISINTERFACE="false"
    fi

    METHODNAME1=$(echo ${ONELINE} | awk '{print $1}')
    # METHODNAME2=$(echo ${ONELINE} | sed 's/.*(/(/g' | sed 's/).*/)/g')
    METHODNAME2="()"
    METHODNAME=$(echo ${METHODNAME1}${METHODNAME2})
    if [ "$METHODNAME1" == "$PRIVATECLASS" ]; then
        ISCONSTRUCTOR="true"
    else
        ISCONSTRUCTOR="false"
    fi
    GREPPAT=$(echo ${ONELINE} | sed 's/.*\/\^[[:space:]]*//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/[[:space:]]*\$\/.*//g' | sed 's/\[/\\\[/g' | sed 's/\]/\\\]/g')
    GREPPAT=$(echo "${GREPPAT}[[:space:]]*$")
    # GREPPAT=${GREPPAT#* }
    # GREPPAT=${GREPPAT%* }
    WL=$(grep "${GREPPAT}" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "${GREPPAT}" | wc -l) 

    if [ ${WL} -gt 1 ]; then
        declare RESULT
        declare -i LOCALWL=0
        if [ $ISINTERFACE == "true" ]; then
            ISINTERFACE="false"
            LOCALWL=$(grep "interface $PRIVATECLASS" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "interface $PRIVATECLASS" | wc -l)
            if [ $LOCALWL -ne 1 ]; then
                RESULT="!!! Failed to locate this method (${PRIVATECLASS}.${METHODNAME}) !!!\n"
                count=$((${count} + 1))
                continue
            else
                RESULT="*** Located this method successed! ***\n"
            fi
            SINGLELINE=$(grep -n "interface $PRIVATECLASS" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "interface $PRIVATECLASS" | cut -d ':' -f 1)
        elif [ $ISCLASS == "true" ]; then
            ISCLASS="false"
            LOCALWL=$(grep "class $PRIVATECLASS" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "class $PRIVATECLASS" | wc -l)
            if [ $LOCALWL -ne 1 ]; then
                RESULT="!!! Failed to locate this method!!! (${PRIVATECLASS}.${METHODNAME}) ***\n"
                count=$((${count} + 1))
                continue
            else
                RESULT="*** Located this method successed! ***\n"
            fi
            SINGLELINE=$(grep -n "class $PRIVATECLASS" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "class $PRIVATECLASS" | cut -d ':' -f 1)
        fi
        if [ "$DEBUG" == "true" ]; then
            PrintMessage msg1 "$RESULT"
        fi
        findBlock classBlock $1 $SINGLELINE
        if [ $STARTLINE -eq $ENDLINE ]; then
            echo "!!! a singleline class !!!"
            count=$((${count} + 1))
            continue
        fi
        LOCALWL=$(sed -n "${STARTLINE},${ENDLINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "$GREPPAT" | wc -l)
        if [ $LOCALWL -le 1 ]; then
            SINGLELINE=$(sed -n "${STARTLINE},${ENDLINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -n "$GREPPAT" | cut -d ':' -f 1)
        else
            if [ $DEBUG == "true" ]; then
                echo "!!! There also more than one prototype for this method in class ($PRIVATECLASS) !!!"
            fi
            CONTENTVAR=$(sed -n "${STARTLINE},${ENDLINE}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep -n "$GREPPAT" | sed 's/:.*//g')
            declare -i localSTARTLINE=$STARTLINE
            SINGLELINE=0
            for var in $CONTENTVAR
            do
                STARTLINE=$localSTARTLINE
                if [ -z "$(sed -n "${STARTLINE},${var}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "new .*(.*{")" ]; then
                    SINGLELINE=$var
                    break
                else
                    declare innervar
                    declare -i innersingleline=$var
                    while [ $innersingleline -gt $STARTLINE ]
                    do
                        innervar=$(sed -n "${innersingleline}p" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "new .*(.*{") 
                        PRIVATECLASS=$(echo ${innervar%(*} | awk '{print $NF}')
                        if [ -z "$innervar" ]; then
                            innersingleline=$(($innersingleline - 1))
                        else
                            findBlock classBlock $1 $innersingleline
                            if [ $STARTLINE -eq $ENDLINE ]; then
                                echo "!!! a singleline class !!!"
                                innersingleline=$(($innersingleline - 1))
                            elif [ $ENDLINE -gt $var ]; then
                                SINGLELINE=0
                                break
                            else
                                innersingleline=$(($innersingleline - 1))
                                if [ $innersingleline -eq $STARTLINE ]; then
                                    SINGLELINE=$var
                                    break
                                fi
                            fi
                        fi
                    done
                    unset innervar
                    unset innersingleline
                fi
                if [ $SINGLELINE -ne 0 ]; then
                    break
                fi
            done
            unset localSTARTLINE
        fi
        unset var
        if [ $DEBUG == "true" -a $SINGLELINE -eq 0 ]; then
            tput setf 4
            echo "!!! Can't locate this method, there are no definition for this method in ($PRIVATECLASS) !!!"
            tput setf 7
            count=$((${count} + 1))
            continue
        fi
        SINGLELINE=$((${STARTLINE} + ${SINGLELINE} -1))
        sed -i "${SINGLELINE}s/$METHODNAME1/MYTMPNAME&/g" $1
        findBlock methodBlock $1 $SINGLELINE
        addLogToMethod $1
    elif [ "${WL}" -eq 0 ]; then
        if [ "$DEBUG" == "true" ]; then
            PrintMessage msg2
        fi
    else
        SINGLELINE=$(grep -n "$GREPPAT" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep "$GREPPAT" | cut -d ':' -f 1)
        findBlock methodBlock $1 $SINGLELINE
        addLogToMethod $1
    fi
    count=$((${count} + 1))
done

declare tmpCLASSNAMECOLLECTION=$(egrep '[[:space:]]+class[[:space:]]+.*{' $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed 's/.*class//g' | sed 's/{/ {/g' | awk '{print $1}' | sed 's/\n/ /g')
if [ $RECURSION -eq 0 ]; then
    CLASSNAMECOLLECTION=$(echo $CLASSNAMECOLLECTION $tmpCLASSNAMECOLLECTION)
fi
CLASSNAMECOLLECTION=$(echo $CLASSNAMECOLLECTION | sed 's/ /\n/g' | sort -u)
if [ $DEBUG == "true" ]; then
    tput setf 2
    echo "***** begin to handle normal class and inner class *****"
    echo "ClassnameCollection is $CLASSNAMECOLLECTION"
    tput setf 7
fi
declare -i innercount=0
declare -i countsum=$(echo $CLASSNAMECOLLECTION | awk '{print NF}')
if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
    tput setf 3
    echo -e "\nSecond step (2/4): Deal with all classes excepts anonymous inner class (${countsum:-0} classes)."
    tput setf 7
    TASKFINISHEDOLD=0
    TASKFINISHEDNEW=0
fi
if [ ! -z "$CLASSNAMECOLLECTION" ]; then

    if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
        PROBARSTEP=$((200 / $countsum))
        if [ $PROBARSTEP -lt 1 ]; then
            PROBARSTEP=1
        elif [ $PROBARSTEP -gt 2 -a $PROBARSTEP -lt 5 ]; then
            PROBARSTEP=4
        elif [ $PROBARSTEP -gt 5 ]; then
            PROBARSTEP=10
        fi
    fi

    for var in $CLASSNAMECOLLECTION
    do
        # WL=$(egrep "[[:space:]]+class[[:space:]]+$var([[:space:]]*{|[[:space:]]+.*{)" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep "[[:space:]]+class[[:space:]]+$var([[:space:]]*{|[[:space:]]+.*{)" | wc -l)
        WL=$(egrep "class[[:space:]]+$var[[:space:]{]" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep "class[[:space:]]+$var[[:space:]{]" | wc -l)
        if [ $DEBUG == "true" ]; then
            # egrep "[[:space:]]+class[[:space:]]+$var([[:space:]]*{|[[:space:]]+.*{)" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep "[[:space:]]+class[[:space:]]+$var([[:space:]]*{|[[:space:]]+.*{)"
            egrep "class[[:space:]]+$var[[:space:]{]" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep "class[[:space:]]+$var[[:space:]{]"
        fi
        if [ $WL -lt 1 ]; then
            if [ $DEBUG == "true" ]; then
                tput setf 4
                echo "!!! Can't find class $var, maybe it is an interface !!!"
                echo "!!! ClassnameCollection = $CLASSNAMECOLLECTION"
                tput setf 7
            fi
        else
            count=1
            while [ $count -le $WL ]
            do
                # SINGLELINE=$(egrep -n "[[:space:]]+class[[:space:]]+$var([[:space:]]*{|[[:space:]]+.*{)" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep "[[:space:]]+class[[:space:]]+$var([[:space:]]*{|[[:space:]]+.*{)" | sed -n "${count}p" | cut -d ':' -f 1)
                SINGLELINE=$(egrep -n "class[[:space:]]+$var[[:space:]{]" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep "class[[:space:]]+$var[[:space:]{]" | sed -n "${count}p" | cut -d ':' -f 1)
                findBlock classBlock $1 $SINGLELINE "startline"
                workoutIndent $1 $SINGLELINE
                sed -i "${STARTLINE}a ${PREFIX}{Log.d($TAG, \"$LOGPREFIX Create<garycreateline> an instance of type $var $LOGSUFFIX\");}" $1
                if [ $DEBUG == "true" ]; then
                    echo "count = $count, classname = $var"
                fi
                count=$((${count} + 1))
            done
        fi
        if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
            innercount=$(($innercount + 1))
            TASKFINISHEDNEW=$(($innercount * 100 / $countsum / $PROBARSTEP))
            if [ $TASKFINISHEDOLD -ne $TASKFINISHEDNEW ]; then
                TASKFINISHEDOLD=$TASKFINISHEDNEW
                TASKFINISHEDNEW=$(($TASKFINISHEDNEW * $PROBARSTEP))
                updateProBar $TASKFINISHEDNEW
            fi
        fi
    done
else
    if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
        updateProBar 100
    fi
fi
unset innercount
unset countsum


if [ $DEBUG == "true" ]; then
    tput setf 2
    echo "***** begin to handle anonymousclass *****"
    tput setf 7
fi
declare ANONYMOUSINNERCLASS
declare TMPANONYMOUSINNERCLASSABSTRACTFILE=/tmp/${FILENAME%.*}_abstractanonymousinnerclass$RECURSION
egrep 'new[[:space:]]+.*\(.*\)[[:space:]]*{[[:space:]]*$' $1 | grep -v 'new[[:space:]]*.*;' | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep 'new[[:space:]]+.*\(.*\)[[:space:]]*{[[:space:]]*$' | sed 's/){/) {/g' > $TMPANONYMOUSINNERCLASSABSTRACTFILE
while [ ! -z "$(grep '([^()]*)' $TMPANONYMOUSINNERCLASSABSTRACTFILE)" ]
do
    sed -i 's/([^()]*)//g' $TMPANONYMOUSINNERCLASSABSTRACTFILE
done
ANONYMOUSINNERCLASS=$(awk '{print $(NF - 1)}' $TMPANONYMOUSINNERCLASSABSTRACTFILE)
rm -f $TMPANONYMOUSINNERCLASSABSTRACTFILE
declare -i countsum=$(echo $ANONYMOUSINNERCLASS | awk '{print NF}')
declare -i innercount=0
if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
    tput setf 3
    echo -e "\nThird step (3/4): Deal with anonymous inner class (${countsum:-0} anonymous inner classes)."
    tput setf 7
    TASKFINISHEDOLD=0
    TASKFINISHEDNEW=0
fi
if [ ! -z "$ANONYMOUSINNERCLASS" ]; then
    declare LOOPER
    declare NEWFILE
    declare TMPFILE=/tmp/${FILENAME%.*}_tmpfile
    declare -i LINESOFNEWFILE

    if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
        PROBARSTEP=$((200 / $countsum))
        if [ $PROBARSTEP -lt 1 ]; then
            PROBARSTEP=1
        elif [ $PROBARSTEP -gt 2 -a $PROBARSTEP -lt 5 ]; then
            PROBARSTEP=4
        elif [ $PROBARSTEP -gt 5 ]; then
            PROBARSTEP=10
        fi
    fi
    declare GREPLOOPER

    for LOOPER in $ANONYMOUSINNERCLASS
    do
        if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
            innercount=$(($innercount + 1))
            TASKFINISHEDNEW=$(($innercount * 100 / $countsum / $PROBARSTEP))
            if [ $TASKFINISHEDOLD -ne $TASKFINISHEDNEW ]; then
                TASKFINISHEDOLD=$TASKFINISHEDNEW
                TASKFINISHEDNEW=$(($TASKFINISHEDNEW * $PROBARSTEP))
                updateProBar $TASKFINISHEDNEW
            fi
        fi
        PRIVATECLASS=${LOOPER}
        GREPLOOPER=$(echo $LOOPER | sed 's/(/\\(/g' | sed 's/)/\\)/g' | sed 's/\[/\\\[/g' | sed 's/\]/\\\]/g')
        CONTENTVAR=$(egrep "new[[:space:]]+${GREPLOOPER}\(.*\)[[:space:]]*{" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep "new[[:space:]]+${GREPLOOPER}\(.*\)[[:space:]]*{")
        if [ -z "$CONTENTVAR" ]; then
            if [ $DEBUG == "true" ]; then
                tput setf 4
                echo "!!! Can't find new ${LOOPER}() { !!!"
                tput setf 7
            fi
            continue
        fi
        SINGLELINE=$(egrep -n "new[[:space:]]+${GREPLOOPER}\(.*\)[[:space:]]*{" $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | egrep "new[[:space:]]+${GREPLOOPER}\(.*\)[[:space:]]*{" | sed -n '1p' | cut -d ':' -f 1)
        if [ $DEBUG == "true" ]; then
            echo "Find an anonymousclass new ${LOOPER} () {, Singleline = $SINGLELINE"
            sed -n "${SINGLELINE}p" $1
        fi
        findBlock classBlock $1 $SINGLELINE
        declare -i countrightbraces
        countrightbraces=0
        CONTENTVAR=$(sed -n "${ENDLINE}p" $1)
        countrightbraces=$(($countrightbraces + $(echo ${CONTENTVAR} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed "s/[^}]//g" | wc -m) - 1))
        countrightbraces=$(($countrightbraces - $(echo ${CONTENTVAR} | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed -e 's/_hejinyi/\n_hejinyi/g' -e 's/hejinyi_/hejinyi_\n/g' | sed 's/_hejinyi.*hejinyi_//g' | sed '/^$/d' | tr -d "\n" | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | sed "s/[^{]//g" | wc -m) + 1))
        if [ $countrightbraces -eq 0 ]; then
            tput setf 4
            echo "!!! Anonymousinnerclass $LOOPER at line $SINGLELINE in file $ORIGINALFILENAME is not standart, can't handle it !!!"
            tput setf 7
            sed -i "${SINGLELINE}s/new/newhejinyi/g" $1
            continue
        fi
        declare -i tmpvar=$(($ENDLINE - 1))
        if [ $tmpvar -le $STARTLINE ]; then
            tput setf 4
            echo "!!! Anonymousinnerclass $LOOPER at line $SINGLELINE in file $ORIGINALFILENAME is a blank class !!!"
            tput setf 7
            sed -i "${SINGLELINE}s/new/newhejinyi/g" $1
            continue
        fi
        unset tmpvar
        workoutIndent $1 $SINGLELINE
        sed -i "${SINGLELINE}s/new/newhejinyi/g" $1
        NEWFILE="/tmp/${FILENAME%.*}_${LOOPER}_${STARTLINE}_${ENDLINE}.java"
        NEWFILE=$(echo $NEWFILE | sed 's/</_/g' | sed 's/>/_/g')
        STARTLINE=$(($STARTLINE + 1))
        ENDLINE=$(($ENDLINE - 1))
        if [ $DEBUG == "true" ]; then
            echo "anonymousclass new ${LOOPER} () {, Startline = $STARTLINE, Endline = $ENDLINE"
        fi
        echo "${PREFIX}class ${LOOPER} {" > ${NEWFILE}
        sed -n "${STARTLINE},${ENDLINE}p" $1 >> ${NEWFILE}
        declare lastlinecontent
        while [ $countrightbraces -ne 0 ]
        do
            lastlinecontent=$(echo ${lastlinecontent}})
            countrightbraces=$(($countrightbraces - 1))
        done
        echo "${PREFIX}${lastlinecontent}" >> ${NEWFILE}
        unset lastlinecontent
        sed -i 's/MYPREFIX/ /g' ${NEWFILE}
        RECURSION=$(($RECURSION + 1))
        if [ $DEBUG == "true" ]; then
            echo "begin to handle $NEWFILE"
        fi
        $0 ${NEWFILE}
        if [ -z "$(grep "${LOGPREFIX} Create.* $LOOPER ${LOGSUFFIX}" $NEWFILE)" ]; then
            sed -i "1a ${PREFIX}    {Log.d($TAG, \"$LOGPREFIX Create<garycreateline> an instance of type $LOOPER $LOGSUFFIX\");}" $NEWFILE
        fi
        RECURSION=$(($RECURSION - 1))
        sed -i '1d' $NEWFILE
        sed -i '$d' $NEWFILE
        STARTLINE=$(($STARTLINE - 1))
        ENDLINE=$(($ENDLINE + 1))
        head -n ${STARTLINE} $1 > $TMPFILE
        cat $NEWFILE >> $TMPFILE
        sed -n "${ENDLINE},\$p" $1 >> $TMPFILE
        cp $TMPFILE $1
        # rm -f $TMPFILE
        rm -f $NEWFILE
        subsrc=$(echo $NEWFILE | tr '/' '_')
        subsrc=${subsrc#*_}
        rm -f ${DESDIR}/src/$subsrc
        rm -f ${DESDIR}/tag/${subsrc%.*}_tags
        rm -f ${DESDIR}/method/${subsrc%.*}_method
        unset subsrc
    done
    unset LOOPER
    unset GREPLOOPER
    unset NEWFILE
    unset LINESOFNEWFILE
else
    if [ $DEBUG == "false" -a $RECURSION -eq 0 -a -z "$ISDIRECTROY" ]; then
        updateProBar 100
    fi
fi
unset innercount
unset countsum
# Replace every MYPREFIX to 1 whitespaces
clean $1

if [ $RECURSION -eq 0 ]; then
    sed -i '1,$s/newhejinyi/new/g' $1
    sed -i "/MYTMPNAME/s/MYTMPNAME//g" $1
    if grep -q "Log\.d(.*\"$LOGPREFIX .* $LOGSUFFIX\");" $1; then
        if [ -z "$(grep 'import android\.util\.Log;' $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep 'import android\.util\.Log;')" ]; then
            declare -i line
            declare UPORDOWN
            if [ ! -z "$(grep -n 'package.*;' $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep 'package.*;')" ]; then
                line=$(grep -n 'package.*;' $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep 'package.*;' | sed -n '1p' | cut -d ':' -f 1)
                UPORDOWN="down"
            elif [ ! -z "$(grep -n 'import.*;' $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep 'import.*;')" ]; then
                line=$(grep -n 'import.*;' $1 | sed 's/"[^"]*"/ /g' | sed "s/'.'//g" | sed 's/_hejinyi.*hejinyi_//g' | sed 's/^[[:space:]]*\/\/.*//g' | sed 's/\/\/.*//g' | grep 'import.*;' | sed -n '1p' | cut -d ':' -f 1)
                UPORDOWN="down"
            else
                line=1
                UPORDOWN="up"
            fi
            workoutIndent $1 $line
            if [ $UPORDOWN == "up" ]; then
                sed -i "${line}i ${PREFIX}import android.util.Log;\t// added by LogHelpler from gary -$(date +%F) $(date +%T)-" $1
            else
                sed -i "${line}a ${PREFIX}import android.util.Log;\t// added by LogHelpler from gary -$(date +%F) $(date +%T)-" $1
            fi
            unset UPORDOWN
            unset line
            sed -i '/^MYPREFIX/s/MYPREFIX/ /g' "$1"
        fi
    fi

    sed -i "/^[^\/]*boolean DEBUG.*=[[:space:]]*false[[:space:]]*;/s/$/\/\/turn on debug by LogHelpler/g" $1
    sed -i '/\/\/turn on debug by LogHelpler/s/false/true/g' $1
    sed -i "/^[[:space:]]*if.*{[[:space:]]*$/s/^.*$/&\njinyihe    &hejinyiLog.d(${TAG}, \"$LOGPREFIX Enter<garymethodline> & $LOGSUFFIX\");/g" $1
    sed -i "/^.*else.*{[[:space:]]*$/s/^.*$/&\njinyihe    &hejinyiLog.d(${TAG}, \"$LOGPREFIX Enter<garymethodline> & $LOGSUFFIX\");/g" $1
    sed -i "/^.*case.*:[[:space:]]*$/s/^.*$/&\njinyihe    &hejinyiLog.d(${TAG}, \"$LOGPREFIX Enter<garymethodline> & $LOGSUFFIX\");/g" $1
    sed -i "/\/\/.*${LOGPREFIX} Enter.*if.*{/d" $1
    sed -i "/\/\/.*${LOGPREFIX} Enter.*else.*{/d" $1
    sed -i "/\/\/.*${LOGPREFIX} Enter.*case.*:/d" $1
    sed -i "/jinyihe[[:space:]]*if.*DEBUG.*{.*hejinyi/d" $1
    sed -i "/${LOGPREFIX} Enter<.*>.*case.*:/s/Enter<.*>.*case/Enter<garymethodline> case/g" $1
    sed -i "/${LOGPREFIX} Enter<.*>.*if.*{/s/Enter<.*>.*if/Enter<garymethodline> if/g" $1
    sed -i "/${LOGPREFIX} Enter<.*>.*else.*{/s/Enter<.*>.*else/Enter<garymethodline> else/g" $1
    sed -i 's/jinyihe//g' $1
    sed -i '/hejinyi/s/[^[:space:]].*hejinyi//g' $1
    sed -i "/.*$LOGPREFIX Enter<.*> if/N;s/$LOGPREFIX Enter<.*> if.*$LOGPREFIX Leave/$LOGPREFIX Leave/g" $1
    sed -i "/.*$LOGPREFIX Enter<.*> else/N;s/$LOGPREFIX Enter<.*> else.*$LOGPREFIX Leave/$LOGPREFIX Leave/g" $1
    sed -i "/.*$LOGPREFIX Enter<.*> case/N;s/$LOGPREFIX Enter<.*> case.*$LOGPREFIX Leave/$LOGPREFIX Leave/g" $1
    # sed -i "/.*$LOGPREFIX Enter<.*> if.*\".*{/s/if.*\".*{/if (---) {/g" $1
    # sed -i "/.*$LOGPREFIX Enter<.*> else.*\".*{/s/else.*\".*{/else (---) {/g" $1
    # sed -i "/.*$LOGPREFIX Enter<.*> case.*\".*:/s/case.*\".*:/case --- :/g" $1
    sed -i "/.*$LOGPREFIX Enter<.*> if.*\".*{ $LOGSUFFIX/s/ if.*\".*{ $LOGSUFFIX/new line gary\nhejinyi&new line gary\njinyihe/g" $1
    sed -i "/.*$LOGPREFIX Enter<.*> else.*\".*{ $LOGSUFFIX/s/ else.*\".*{ $LOGSUFFIX/new line gary\nhejinyi&new line gary\njinyihe/g" $1
    sed -i "/.*$LOGPREFIX Enter<.*> case.*\".*: $LOGSUFFIX/s/ case.*\".*: $LOGSUFFIX/new line gary\nhejinyi&new line gary\njinyihe/g" $1
    sed -i '/^hejinyi/s/"/\\"/g' $1
    sed -i '/new line gary/N;s/\n//g' $1
    sed -i '/new line gary/N;s/\n//g' $1
    sed -i '/new line gary/s/new line gary[[:space:]]*hejinyi//g;s/new line gary[[:space:]]*jinyihe//g' $1
    unset RECURSION
    unset TAG
    declare LINEREGISTER
    declare LINETOCUT
    LINESOFSOURCEFILE=$(wc -l $1 | awk '{print $1}')
    count=1
    if [ $DEBUG == "false" -a -z "$ISDIRECTROY" ]; then
        tput setf 3
        echo -e "\nLast step (4/4): Replace some strings (lines: $LINESOFSOURCEFILE)"
        tput setf 7
        TASKFINISHEDOLD=0
        TASKFINISHEDNEW=0
    fi
    while [ ! -z "$(grep "$LOGPREFIX maybeunreachedableLeave" $1)" ]
    do
        if [ $DEBUG == "true" ]; then
            echo "while 12, find out unreachedable statement in $1"
        fi
        LINE=$(grep -n '$LOGPREFIX maybeunreachedableLeave' $1 | sed -n '1p' | cut -d ':' -f 1)
        findBlock inclassBlock $1 $LINE
        sed -i "${LINE}s/$LOGPREFIX maybeunreachedableLeave/$LOGPREFIX Leave/g" $1
        echo "$1 $STARTLINE $ENDLINE $LINE" >>  $TMPUNREACHEDABLEFILE
    done
    if [ $DEBUG == "false" -a -z "$ISDIRECTROY" ]; then
        updateProBar 100 
    fi
    if [ -z "$ISDIRECTROY" ]; then
        unreachedMethod
        rm -f /tmp/${FILENAME%.*}_hejinyiLogHelplertmp
        touch /tmp/${FILENAME%.*}_hejinyiLogHelplertmp
        awk '{gsub(/garymethodline|garycreateline/,NR)}{print $0}' $1 >> /tmp/${FILENAME%.*}_hejinyiLogHelplertmp
        mv /tmp/${FILENAME%.*}_hejinyiLogHelplertmp $1
    fi
    ENDTIME=$(date +%s)
    if [ -z "$ISDIRECTROY" ]; then
        tput setf 2
        echo "Finished at [$(date +%T)]"
        echo "TotalTime: $((($ENDTIME - $STARTTIME) / 3600))h $((($ENDTIME - $STARTTIME) % 3600 / 60))m $((($ENDTIME - $STARTTIME) % 60))s"
        tput setf 7
    fi
    unset LINEREGISTER
    unset LINETOCUT
    if [ ! -z "$ISDIRECTROY" ]; then
        while [ -f "$LOCKFILE" ]
        do
            cd .
        done
        touch $LOCKFILE
        sed -i "/pid=$$/d" $HANDLINGFILE
        rm -f $LOCKFILE
    fi
    rm -f $SRCFILE
    rm -f $TAGFILE
    rm -f $METHODFILE
fi
